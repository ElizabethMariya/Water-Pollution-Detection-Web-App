# -*- coding: utf-8 -*-
"""nammamodel_RF.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16puf7oA_TupqtMMaDTmwLFGLOI88eAZZ
"""

!pip install lime
!pip install Shap

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, accuracy_score
from sklearn.ensemble import GradientBoostingRegressor
from sklearn.metrics import mean_squared_error

# For interpretability (optional)
import shap
import lime

# Assuming you have a CSV file named 'lake_pollution_data.csv'
df = pd.read_csv('/content/synthetic_waterquality_data_final.csv')

# Display the first few rows of the dataset
print(df.head())

# Define pollution classification based on the thresholds provided
def classify_pollution(row):
    # Define thresholds for each parameter
    thresholds = {
        'pH': (6.5, 8.5),
        'Turbidity': 5,
        'Alkalinity_Level': 200,
        'Temperature': 25,
        'Dissolved_Oxygen': 9,
        'Nitrogen_Levels': 10,
        'Total_Dissolved_Solids': 500,
        'Calcium_Hardness': 75,
        'Magnesium_Hardness': 30,
        'Chloride_Levels': 250,
        'Contaminants': 100,
        'Bacteria_Level': 2000,
        'Cadmium': 0.005,
        'Iron': 0.3,
        'Lead': 0.02,
        'Mercury': 0.0002,
        'Zinc': 0.05,
        'Nitrate': 3,
        'Nitrite': 0.1,
        'Nickel': 0.15
    }

    # Define the classification conditions
    if (
        row['pH'] < thresholds['pH'][0] or row['pH'] > thresholds['pH'][1] or
        row['Turbidity'] > thresholds['Turbidity'] or
        row['Alkalinity_Level'] > thresholds['Alkalinity_Level'] or
        row['Temperature'] > thresholds['Temperature'] or
        row['Dissolved_Oxygen'] > thresholds['Dissolved_Oxygen'] or
        row['Nitrogen_Levels'] > thresholds['Nitrogen_Levels'] or
        row['Total_Dissolved_Solids'] > thresholds['Total_Dissolved_Solids'] or
        row['Calcium_Hardness'] > thresholds['Calcium_Hardness'] or
        row['Magnesium_Hardness'] > thresholds['Magnesium_Hardness'] or
        row['Chloride_Levels'] > thresholds['Chloride_Levels'] or
        row['Contaminants'] > thresholds['Contaminants'] or
        row['Bacteria_Level'] > thresholds['Bacteria_Level'] or
        row['Cadmium'] > thresholds['Cadmium'] or
        row['Iron'] > thresholds['Iron'] or
        row['Lead'] > thresholds['Lead'] or
        row['Mercury'] > thresholds['Mercury'] or
        row['Zinc'] > thresholds['Zinc'] or
        row['Nitrate'] > thresholds['Nitrate'] or
        row['Nitrite'] > thresholds['Nitrite'] or
        row['Nickel'] > thresholds['Nickel']
    ):
        return 1  # Polluted
    else:
        return 0  # Not polluted

# Apply the function to create a new column in the DataFrame
df['Is_Polluted'] = df.apply(classify_pollution, axis=1)

# Display the first few rows of the updated DataFrame
print(df[['Lake_Name', 'Is_Polluted']].head())

import pandas as pd

# Define the thresholds and weights for each parameter
thresholds = {
    'pH': (6.5, 8.5),
    'Turbidity': 5,
    'Alkalinity_Level': 200,
    'Temperature': 25,
    'Dissolved_Oxygen': 9,
    'Nitrogen_Levels': 10,
    'Total_Dissolved_Solids': 500,
    'Calcium_Hardness': 75,
    'Magnesium_Hardness': 30,
    'Chloride_Levels': 250
}

weights = {
    'pH': 2,
    'Turbidity': 1,
    'Alkalinity_Level': 1,
    'Temperature': 1,
    'Dissolved_Oxygen': 1,
    'Nitrogen_Levels': 2,
    'Total_Dissolved_Solids': 1,
    'Calcium_Hardness': 1,
    'Magnesium_Hardness': 1,
    'Chloride_Levels': 1
}

# Define the pollution score threshold
pollution_score_threshold = 5

# Function to classify pollution based on the scoring system
def classify_pollution(row):
    pollution_score = 0

    if row['pH'] < thresholds['pH'][0] or row['pH'] > thresholds['pH'][1]:
        pollution_score += weights['pH']
    if row['Turbidity'] > thresholds['Turbidity']:
        pollution_score += weights['Turbidity']
    if row['Alkalinity_Level'] > thresholds['Alkalinity_Level']:
        pollution_score += weights['Alkalinity_Level']
    if row['Temperature'] > thresholds['Temperature']:
        pollution_score += weights['Temperature']
    if row['Dissolved_Oxygen'] > thresholds['Dissolved_Oxygen']:
        pollution_score += weights['Dissolved_Oxygen']
    if row['Nitrogen_Levels'] > thresholds['Nitrogen_Levels']:
        pollution_score += weights['Nitrogen_Levels']
    if row['Total_Dissolved_Solids'] > thresholds['Total_Dissolved_Solids']:
        pollution_score += weights['Total_Dissolved_Solids']
    if row['Calcium_Hardness'] > thresholds['Calcium_Hardness']:
        pollution_score += weights['Calcium_Hardness']
    if row['Magnesium_Hardness'] > thresholds['Magnesium_Hardness']:
        pollution_score += weights['Magnesium_Hardness']
    if row['Chloride_Levels'] > thresholds['Chloride_Levels']:
        pollution_score += weights['Chloride_Levels']

    return 1 if pollution_score > pollution_score_threshold else 0

import pandas as pd
import random
from sklearn.model_selection import train_test_split

# Function to assign causes of pollution
def assign_cause(row):
    causes = {
        "pH": ("Industrial pollution, acid rain, agricultural runoff", row['pH']),
        "Contaminants": ("Industrial waste, agricultural runoff, urban runoff", row['Contaminants']),
        "Bacteria_Level": ("Untreated sewage, agricultural runoff, contamination from livestock or wildlife", row['Bacteria_Level']),
        "Temperature": ("Thermal pollution from industrial processes, climate change", row['Temperature']),
        "Turbidity": ("Soil erosion, construction activities, urban runoff, wastewater discharge", row['Turbidity']),
        "Dissolved_Oxygen": ("Organic pollution, nutrient runoff leading to algal blooms, high bacterial activity", -row['Dissolved_Oxygen']),
        "Alkalinity_Level": ("Natural mineral deposits, industrial waste", row['Alkalinity_Level']),
        "Calcium_Hardness": ("Natural mineral deposits, industrial discharge", row['Calcium_Hardness']),
        "Magnesium_Hardness": ("Natural mineral deposits, industrial discharge", row['Magnesium_Hardness']),
        "Sodium": ("Industrial discharge, agricultural runoff", row['Sodium']),
        "Chloride_Levels": ("Industrial discharge, road salt runoff, sewage", row['Chloride_Levels']),
        "Total_Dissolved_Solids": ("Agricultural runoff, industrial discharge, urban runoff", row['Total_Dissolved_Solids']),
        "Cadmium": ("Industrial discharge, mining operations", row['Cadmium']),
        "Iron": ("Industrial discharge, natural mineral deposits", row['Iron']),
        "Lead": ("Industrial discharge, old plumbing systems", row['Lead']),
        "Mercury": ("Industrial discharge, mining operations", row['Mercury']),
        "Zinc": ("Industrial discharge, mining operations", row['Zinc']),
        "Nitrate": ("Agricultural runoff, sewage discharge, industrial effluents containing nitrogen compounds", row['Nitrate']),
        "Nitrite": ("Agricultural runoff, sewage discharge, industrial effluents containing nitrogen compounds", row['Nitrite']),
        "Nickel": ("Industrial discharge, mining operations", row['Nickel'])
    }

    thresholds = {
        "pH": (6.5, 8.5),
        "Contaminants": 100,
        "Bacteria_Level": 2000,
        "Temperature": 35,
        "Turbidity": 5,
        "Dissolved_Oxygen": 5,
        "Alkalinity_Level": 200,
        "Calcium_Hardness": 200,
        "Magnesium_Hardness": 100,
        "Sodium": 50,
        "Chloride_Levels": 100,
        "Total_Dissolved_Solids": 500,
        "Cadmium": 0.005,
        "Iron": 0.3,
        "Lead": 0.02,
        "Mercury": 0.0002,
        "Zinc": 0.05,
        "Nitrate": 3,
        "Nitrite": 0.1,
        "Nickel": 0.15
    }

    significant_causes = {key: causes[key] for key in causes if (
        (key == "Dissolved_Oxygen" and row[key] < thresholds[key]) or
        (key == "pH" and not (thresholds[key][0] <= row[key] <= thresholds[key][1])) or
        (key != "Dissolved_Oxygen" and key != "pH" and row[key] > thresholds[key])
    )}

    if significant_causes:
        max_cause = max(significant_causes.items(), key=lambda x: abs(x[1][1]))
        return max_cause[1][0]

    return "Unknown/Multiple causes"

df['Cause_of_Pollution'] = df.apply(assign_cause, axis=1)

# Define effects and suggestions based on the cause
effects = {
    "Industrial pollution, acid rain, agricultural runoff": (
        "Possible Effects: Skin irritation, respiratory issues, harm to aquatic life, soil degradation.",
        "Suggestions: Reduce industrial emissions, use cleaner energy sources, regulate agricultural runoff."
    ),
    "Industrial waste, agricultural runoff, urban runoff": (
        "Possible Effects: Contamination of drinking water, harm to aquatic ecosystems, bioaccumulation of toxins in food chains.",
        "Suggestions: Proper waste disposal, better agricultural practices, reducing urban runoff."
    ),
    "Untreated sewage, agricultural runoff, contamination from livestock or wildlife": (
        "Possible Effects: Waterborne diseases, algal blooms, oxygen depletion in water bodies.",
        "Suggestions: Treat sewage, manage agricultural runoff, control livestock access to water bodies."
    ),
    "Thermal pollution from industrial processes, climate change": (
        "Possible Effects: Disruption of aquatic ecosystems, altered growth rates of aquatic species, increased vulnerability to disease.",
        "Suggestions: Use cooling ponds, implement thermal pollution control measures, mitigate climate change."
    ),
    "Soil erosion, construction activities, urban runoff, wastewater discharge": (
        "Possible Effects: Reduced water clarity, clogged fish gills, reduced light penetration affecting aquatic plants.",
        "Suggestions: Erosion control, proper wastewater management, reducing construction impact on water bodies."
    ),
    "Organic pollution, nutrient runoff leading to algal blooms, high bacterial activity": (
        "Possible Effects: Oxygen depletion, fish kills, harmful algal blooms.",
        "Suggestions: Reduce nutrient runoff, promote organic farming, manage waste effectively."
    ),
    "Natural mineral deposits, industrial waste": (
        "Possible Effects: Altered water pH, harm to aquatic life, potential toxicity to humans.",
        "Suggestions: Monitor and regulate mineral content, treat industrial waste."
    ),
    "Natural mineral deposits, industrial discharge": (
        "Possible Effects: Hard water issues, scaling in pipes, potential health impacts from long-term exposure.",
        "Suggestions: Use water softeners, regulate industrial discharge."
    ),
    "Industrial discharge, agricultural runoff": (
        "Possible Effects: Contamination of drinking water, harm to aquatic life, potential toxicity to humans.",
        "Suggestions: Reduce industrial and agricultural runoff, implement better waste management practices."
    ),
    "Industrial discharge, road salt runoff, sewage": (
        "Possible Effects: Harm to freshwater ecosystems, altered soil composition, potential health impacts.",
        "Suggestions: Reduce road salt use, treat sewage, monitor chloride levels."
    ),
    "Agricultural runoff, industrial discharge, urban runoff": (
        "Possible Effects: Contamination of water supplies, harm to aquatic ecosystems, soil degradation.",
        "Suggestions: Implement better agricultural practices, reduce industrial discharge, manage urban runoff."
    ),
    "Industrial discharge, mining operations": (
        "Possible Effects: Heavy metal poisoning, bioaccumulation in food chains, harm to human and animal health.",
        "Suggestions: Treat industrial and mining waste, monitor heavy metal levels."
    ),
    "Agricultural runoff, sewage discharge, industrial effluents containing nitrogen compounds": (
        "Possible Effects: Nitrate contamination in drinking water, blue baby syndrome, eutrophication.",
        "Suggestions: Reduce agricultural runoff, treat sewage, regulate industrial effluents."
    ),
    "Agricultural runoff, sewage discharge, industrial effluents containing nitrogen compounds": (
        "Possible Effects: Nitrite contamination in drinking water, harm to aquatic life, oxygen depletion.",
        "Suggestions: Reduce agricultural runoff, treat sewage, regulate industrial effluents."
    ),
    "Unknown/Multiple causes": (
        "Possible Effects: Various health and environmental impacts.",
        "Suggestions: Comprehensive water quality monitoring, addressing all potential sources of pollution."
    )
}

# Function to assign effects and suggestions
def assign_effects_and_suggestions(row):
    cause = row['Cause_of_Pollution']
    return effects[cause] if cause in effects else ("Unknown effects", "Unknown suggestions")

# Apply the function to assign effects and suggestions
df[['Effects', 'Suggestions']] = df.apply(assign_effects_and_suggestions, axis=1, result_type="expand")

# Display the updated dataset with causes, effects, and suggestions
print(df[['Cause_of_Pollution', 'Effects', 'Suggestions']].head())

from sklearn.model_selection import train_test_split

# Define the features (X) and targets (y)
features = ['pH', 'Contaminants', 'Bacteria_Level', 'Temperature', 'Turbidity', 'Dissolved_Oxygen',
            'Alkalinity_Level', 'Calcium_Hardness', 'Magnesium_Hardness', 'Sodium', 'Chloride_Levels',
            'Total_Dissolved_Solids', 'Cadmium', 'Iron', 'Lead', 'Mercury', 'Zinc', 'Nitrate', 'Nitrite', 'Nickel']

X = df[features]

# Define targets for classification
y_classification = df['Cause_of_Pollution']  # Target for classification
y_effects = df['Effects']  # Target for effects
y_suggestions = df['Suggestions']  # Target for suggestions

# Split the data into training and testing sets for each target
X_train, X_test, y_train_classification, y_test_classification = train_test_split(X, y_classification, test_size=0.2, random_state=42)
_, _, y_train_effects, y_test_effects = train_test_split(X, y_effects, test_size=0.2, random_state=42)
_, _, y_train_suggestions, y_test_suggestions = train_test_split(X, y_suggestions, test_size=0.2, random_state=42)

# Check the first few rows of the training sets to verify
print("Training features:\n", X_train.head())
print("Training classification targets:\n", y_train_classification.head())
print("Training effects targets:\n", y_train_effects.head())
print("Training suggestions targets:\n", y_train_suggestions.head())

from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report

# Train a Random Forest Classifier for Cause of Pollution
clf_cause = RandomForestClassifier(n_estimators=100, random_state=42)
clf_cause.fit(X_train, y_train_classification)

# Predict on the test data for Cause of Pollution
y_pred_cause = clf_cause.predict(X_test)

# Train a Random Forest Classifier for Effects
clf_effects = RandomForestClassifier(n_estimators=100, random_state=42)
clf_effects.fit(X_train, y_train_effects)

# Predict on the test data for Effects
y_pred_effects = clf_effects.predict(X_test)

# Train a Random Forest Classifier for Suggestions
clf_suggestions = RandomForestClassifier(n_estimators=100, random_state=42)
clf_suggestions.fit(X_train, y_train_suggestions)

# Predict on the test data for Suggestions
y_pred_suggestions = clf_suggestions.predict(X_test)

# Print classification reports for each target
print("Classification Report for Cause of Pollution:\n", classification_report(y_test_classification, y_pred_cause))
print("Classification Report for Effects:\n", classification_report(y_test_effects, y_pred_effects))
print("Classification Report for Suggestions:\n", classification_report(y_test_suggestions, y_pred_suggestions))

from sklearn.metrics import classification_report, accuracy_score

# Evaluate the model performance for Cause of Pollution
print("Classification Report for Cause of Pollution:\n", classification_report(y_test_classification, y_pred_cause))
print("Accuracy for Cause of Pollution:", accuracy_score(y_test_classification, y_pred_cause))

# Evaluate the model performance for Effects
print("Classification Report for Effects:\n", classification_report(y_test_effects, y_pred_effects))
print("Accuracy for Effects:", accuracy_score(y_test_effects, y_pred_effects))

# Evaluate the model performance for Suggestions
print("Classification Report for Suggestions:\n", classification_report(y_test_suggestions, y_pred_suggestions))
print("Accuracy for Suggestions:", accuracy_score(y_test_suggestions, y_pred_suggestions))

from sklearn.metrics import classification_report, accuracy_score
import joblib

# Evaluate the model performance for Cause of Pollution
print("Classification Report for Cause of Pollution:\n", classification_report(y_test_classification, y_pred_cause))
print("Accuracy for Cause of Pollution:", accuracy_score(y_test_classification, y_pred_cause))

# Evaluate the model performance for Effects
print("Classification Report for Effects:\n", classification_report(y_test_effects, y_pred_effects))
print("Accuracy for Effects:", accuracy_score(y_test_effects, y_pred_effects))

# Evaluate the model performance for Suggestions
print("Classification Report for Suggestions:\n", classification_report(y_test_suggestions, y_pred_suggestions))
print("Accuracy for Suggestions:", accuracy_score(y_test_suggestions, y_pred_suggestions))

# Save the trained model
joblib.dump(clf, 'nammajal_lake_pollution_model.pkl')